**模板就是类型参数化**

1. 函数模板**自动推导**不会发生隐式转换
2. 函数模板**显示指定**可以发生隐式转换 

## 调用规则

1. 如果函数模板和普通函数都可以实现，优先调用普通函数；
2. 可以通过**空模板参数列表**来强制调用函数模板；
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板；

## 模板的局限性

模板并不是万能的，有些特定的数据类型，需要用具体化方式做特殊实现

## 类模板

template <> 后面紧跟的是一个类

```C++
template <typename NameType, typename AgeType> 
class Person 
{
public:
    Person(NameType name, AgeType age) : name(name), age(age) {}

    NameType name;
    AgeType age;
};
```


## 类模板和函数模板的主要区别

1. 类模板没有自动类型推导 --- 类本身就是实例的模板
2. 类模板在函数参数列表中可以有默认参数

## 类模板中成员函数创建时机

1. 普通类中的成员函数一开始就可以创建；
2. 类模板中的成员函数再调用时才创建；

## 类模板对象做函数参数

1. 指定传入的类型 - 直接显示对象的数据类型；
2. 参数模板化 - 将对象中的参数变为模板进行传递；
3. 整个类模板化 - 将这个对象类型模板化进行传递；

## 类模板与继承
