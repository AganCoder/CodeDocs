# C++ 模板-初探 

## 本文目标

模板？泛型？泛型编程？听起来好高大上，看着别人写的代码，看得也是一头雾水，完全不知道什么意义....

你完全没必要被这些看起来高大上的概念吓到，只要跟着我一点点的来，你会发现理解他们没有想象中的难，最起码看完本篇教程后，你可以分析别人的代码，自己写一些简单的模板代码。

## 什么是泛型编程？

什么是泛型编程？[维基百科](https://zh.wikipedia.org/zh-hans/泛型编程):

> 泛型程序设计（英文：generic programming）是程序设计语言的一种风格或范型。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。

总结就是**类型参数化**，还是不懂？接着往下看.

**需求1:** 需要交换两个 int 和 double 类型数据, 很简单，你很快就完成了。

```c++
void swapInt(int &a, int &b) { 
    int temp = a;
    a = b;
    b = temp;    
}

void swapDouble(double &a, double &b) { 
    double temp = a;
    a = b;
    b = temp;    
}
```

观察着 `swapInt` 和 `swapDouble`, 它们之间除了类型不一致，其他的操作都是一直。

C++泛型编程就是解决这种问题的，

```c++
// 注意：这事一种理想情况
void swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}
```
如果系统能够自动推到类型，然后自动进行调用，这样就非常理想了。

C++ 主要通过**模板**来实现类型参数化的泛型

## 什么是模板

**模板就是类型参数化**

1. 函数模板**自动推导**不会发生隐式转换
2. 函数模板**显示指定**可以发生隐式转换 

## 调用规则

1. 如果函数模板和普通函数都可以实现，优先调用普通函数；
2. 可以通过**空模板参数列表**来强制调用函数模板；
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板；

## 模板的局限性

模板并不是万能的，有些特定的数据类型，需要用具体化方式做特殊实现

## 类模板

template <> 后面紧跟的是一个类

```C++
template <typename NameType, typename AgeType> 
class Person 
{
public:
    Person(NameType name, AgeType age) : name(name), age(age) {}

    NameType name;
    AgeType age;
};
```


## 类模板和函数模板的主要区别

1. 类模板没有自动类型推导 --- 类本身就是实例的模板
2. 类模板在函数参数列表中可以有默认参数

## 类模板中成员函数创建时机

1. 普通类中的成员函数一开始就可以创建；
2. 类模板中的成员函数再调用时才创建；

## 类模板对象做函数参数

1. 指定传入的类型 - 直接显示对象的数据类型；
2. 参数模板化 - 将对象中的参数变为模板进行传递；
3. 整个类模板化 - 将这个对象类型模板化进行传递；

## 类模板与继承

